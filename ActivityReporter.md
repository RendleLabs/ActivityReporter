# ActivityReporter
Generate HTML reports from .NET DiagnosticSource Activity outputs

## Overview

Microsoft have built a new abstraction, **DiagnosticSource**, for gathering low-level
diagnostics and metrics, designed for the cross-platform .NET Core framework,
but available as a NuGet package for all current .NET versions. DiagnosticSource
breaks the coupling between Producers and Consumers of diagnostic data: Producers can
create and write to named sources independently;
Consumers can attach to arbitrary sources
and process the data however they want. Everything runs in-process, so performance
overhead is low and there is no complication to deployments.

Many of the new Microsoft frameworks, like ASP.NET Core and Entity Framework Core,
are already using DiagnosticSource to publish diagnostic data, as are certain
components in the BCL/FCL, including `System.Net.Http`.

We currently have `System.Diagnostics.DiagnosticSource` version 4.3.0 on the internal
NuGet servers; I have put in an upgrade request to get the current version, 4.4.1,
which adds a new Activity feature that is particularly useful for performance metrics.

## Work in progress

I've created some basic building blocks to enable the use of DiagnosticSource in
Morgan Stanley software, particularly for gathering performance metrics to enable
easy profiling of applications and services.

### Activity XML Sink

This is a very simple component that watches for DiagnosticSources being created,
subscribes to them based on a predicate, and writes all the events to XML files
in a directory hierarchy based on Source Names. These XML files can then be processed
outside the application to extract and use the data.

### Activity Reporter

Reporter is a console application that uses the XML files generated by the XML Sink
to build a self-contained, single-file HTML document that shows activity timings
in a collapsible, nested chart. These documents can be shared, emailed, attached to
JIRA tickets, checked into source control, or whatever, to track the progress
of performance efforts.

### Loupe Sink

For Carbon and other projects that use Gibraltar Loupe, there is a sink to write
DiagnosticSource Activity metrics into Loupe directly, allowing them to be used
alongside the existing logs and metrics we are already generating.

## Supporting DiagnosticSource

Adding DiagnosticSource metrics to your components or applications is easy.

1. Add the `System.Diagnostics.DiagnosticSource` package to your project(s).
1. Create a named `DiagnosticSource` to write to.
1. Write events to it, or use the Activity feature for timing metrics.

### Creating a DiagnosticSource

It's a good idea to create multiple DiagnosticSources within a component so that
consumers can pick and choose the ones they are interested in. One obvious approach is to create a DiagnosticSource per class, using the fully-qualified class name
as the Source name. If you need to use more than one source within a class, you
should still prefix all the source names with the fully-qualified class name as
it makes it easier for consumers to use pattern-based predicates. Equally, if multiple
classes within a component need to write to the same Source, then prefix the name with
the component namespace.

```c#
public class Ticker
{
    private static readonly DiagnosticSource _diagnostics =
        new DiagnosticListener(typeof(Ticker).FullName);
}
```

(Yes, you create a `DiagnosticListener` to use as a `DiagnosticSource`.
Don't blame me. I didn't write the library.)

### Writing events

Singular events, such as counters, can be handled with the `Write` method:

```c#
public IObservable<Symbol> Subscribe(string market)
{
    if (_diagnostics.IsEnabled("Subscribe"))
    {
        _diagnostics.Write("Subscribe", new { market });
    }
}
```

The second argument to `Write` is of type `object`, so you can pass any data you
like with the event, including anonymous objects.

Place a guard around the `Write` call so that if there are no active consumers
on your source, you won't incur the overhead of creating the argument object.
guard code can be quite verbose, so I use an extension method like this:

```c#
public static class DiagnosticSourceExtensions
{
    public static DiagnosticSource IfEnabled(this DiagnosticSource source, string name)
        => source.IsEnabled(name) ? source : null;
}
```

Now you can write the above code like this, still avoiding creating the anonymous
object if the source is not enabled:

```c#
public IObservable<Symbol> Subscribe(string market)
{
    _diagnostics.IfEnabled("Subscribe")?.Write("Subscribe", new { market });
}
```

The C# compiler turns the Elvis operator (`?.`) into an if guard clause in the
compiled code.

### Activity Timers

The Activity API was added in version `4.4.0` of the package. It allows you to time
operations using Start/Stop semantics, and supports nested activities using strange
`AsyncLocal` magic.

Record activities with the `Activity` type and the `StartActivity` and `StopActivity`
methods on `DiagnosticSource`:

```c#
private async Task UpdateAsync(string market)
{
    Activity activity;
    if (_diagnostics.IsEnabled("Update"))
    {
        activity = new Activity("Update");
        _diagnostics.StartActivity(activity, );
    }

    await _client.UpdateAsync(market);

    if (_diagnostics.IsEnabled("Update"))
    {
        _diagnostics.StopActivity(activity, null);
    }
}
```

This is pretty verbose, so I use an extension method over `DiagnosticSource` that
returns a disposable object, something like this (simplified):

```c#
public static class DiagnosticSourceActivityExtensions
{
    private static readonly ActivityTimer _nullTimer;

    public static DiagnosticSource IfEnabled(this DiagnosticSource source, string name)
        => source.IsEnabled(name) ? source : null;

    public static ActivityTimer Timer(this DiagnosticSource source, string operationName)
    {
        if (!_source.IsEnabled())
        {
            return _nullTimer;
        }
        var activity = new Activity(operationName);
        source.StartActivity(activity, null);
        return new ActivityTimer(source, activity);
    }
    public struct ActivityTimer : IDisposable
    {
        private readonly bool _null;
        internal ActivityTimer(DiagnosticSource source, Activity activity)
        {
            ...
        }

        public Dispose()
        {
            if (_source == null) return;
            if (_source.IsEnabled(activity.OperationName))
            {
                _source.StopActivity(activity, null);
            }
        }
    }
}
```

Using a `struct` for the timer means faster object creation and no GC overhead.
The returned type is the struct itself rather than `IDisposable` to avoid boxing;
the `using` statement works with any type that has a `void Dispose()` method, so
the above code becomes:

```c#
private async Task UpdateAsync(string market)
{
    using (_diagnostics.Timer("Update"))
    {
        await _client.UpdateAsync(market);
    }
}
```

There is more depth to the Activity API; I recommend reading the [User Guide on GitHub](https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.DiagnosticSource/src/ActivityUserGuide.md) for more details.

## Sinks (i.e. Consumers)

The consumer code is currently in the Carbon solution. It may be useful to extract it
into shared packages when our NuGet capability makes sharing easier.

The code is in the `Carbon.Diagnostics` project. An instance of `DiagnosticSourceActivityXmlSink` is created as soon as the application starts to capture metrics from all startup activities.

## Reporter

Activity Reporter is a console application written in .NET Core 2.0. I'm using the [CoreRT](https://github.com/dotnet/corert) project to build a native Windows x64 executable for easier distribution, so you can just download it and put it somewhere on your path.

In the base directory containing the XML files generated by the Sink, just run `actrep` and
it will create an `activityreport.html` file that you can view in Chrome, Firefox, or any browser
that properly supports ES2015 and CSS3 (so, not Internet Explorer).

## Useful links

- [DiagnosticSource User's Guide](https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.DiagnosticSource/src/DiagnosticSourceUsersGuide.md)
- [Activity User Guide](https://github.com/dotnet/corefx/blob/master/src/System.Diagnostics.DiagnosticSource/src/ActivityUserGuide.md)